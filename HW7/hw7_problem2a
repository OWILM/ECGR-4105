# HW7 Problem 2a â€“ ResNet-10 
# Baseline version (NO regularization)

import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision
import torchvision.transforms as transforms
from torch.utils.data import DataLoader
import time

# Use GPU
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("Using device:", device)

# CIFAR-10 preprocess
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2470, 0.2435, 0.2616))
])

train_set = torchvision.datasets.CIFAR10(root="./data", train=True,
                                         download=True, transform=transform)
test_set  = torchvision.datasets.CIFAR10(root="./data", train=False,
                                         download=True, transform=transform)

train_loader = DataLoader(train_set, batch_size=64, shuffle=True)
test_loader  = DataLoader(test_set, batch_size=64, shuffle=False)


# RESIDUAL BLOCK
# Conv -> BN -> ReLU -> Conv -> BN -> +skip -> ReLU
class ResBlock(nn.Module):
    def __init__(self, channels, use_bn=True, dropout_p=0.0):
        super().__init__()
        self.use_bn = use_bn
        self.dropout_p = dropout_p

        self.conv1 = nn.Conv2d(channels, channels, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(channels, channels, kernel_size=3, padding=1)

        if use_bn:
            self.bn1 = nn.BatchNorm2d(channels)
            self.bn2 = nn.BatchNorm2d(channels)

        if dropout_p > 0:
            self.dropout = nn.Dropout2d(p=dropout_p)

    def forward(self, x):
        identity = x
        
        out = self.conv1(x)
        if self.use_bn: out = self.bn1(out)
        out = F.relu(out)

        out = self.conv2(out)
        if self.use_bn: out = self.bn2(out)

        if self.dropout_p > 0:
            out = self.dropout(out)

        out += identity
        out = F.relu(out)
        return out


# RESNET-10
# Conv -> BN -> ReLU -> 10 Residual Blocks -> GAP -> FC
class ResNet10(nn.Module):
    def __init__(self, channels=32, use_bn=True, dropout_p=0.0):
        super().__init__()
        self.use_bn = use_bn

        self.conv_in = nn.Conv2d(3, channels, kernel_size=3, padding=1)
        if use_bn:
            self.bn_in = nn.BatchNorm2d(channels)

        self.blocks = nn.Sequential(
            *[ResBlock(channels, use_bn, dropout_p) for _ in range(10)]
        )

        self.fc = nn.Linear(channels, 10)

    def forward(self, x):
        out = self.conv_in(x)
        if self.use_bn: out = self.bn_in(out)
        out = F.relu(out)

        out = self.blocks(out)

        out = F.adaptive_avg_pool2d(out, 1)
        out = out.view(out.size(0), -1)
        return self.fc(out)


# Training + Evaluation
def train_one_epoch(model, loader, loss_fn, optimizer):
    model.train()
    total_loss = 0

    for imgs, labels in loader:
        imgs, labels = imgs.to(device), labels.to(device)

        preds = model(imgs)
        loss = loss_fn(preds, labels)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        total_loss += loss.item()

    return total_loss / len(loader)

def evaluate(model, loader):
    model.eval()
    correct, total = 0, 0

    with torch.no_grad():
        for imgs, labels in loader:
            imgs, labels = imgs.to(device), labels.to(device)
            preds = model(imgs)
            _, predicted = torch.max(preds, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    return correct / total


# Problem 2a (50 epochs)

model = ResNet10(channels=32, use_bn=True, dropout_p=0.0).to(device)
print("Model parameters:", sum(p.numel() for p in model.parameters()))

loss_fn = nn.CrossEntropyLoss()
optimizer = torch.optim.SGD(model.parameters(), lr=0.01)

start_time = time.time()

EPOCHS = 50

for epoch in range(1, EPOCHS + 1):
    loss = train_one_epoch(model, train_loader, loss_fn, optimizer)
    acc = evaluate(model, test_loader)
    print(f"Epoch {epoch}/{EPOCHS} | Loss: {loss:.4f} | Accuracy: {acc:.4f}")

total_time = time.time() - start_time

print("\nTraining finished.")
print(f"Total Training Time: {total_time/60:.2f} minutes")
final_acc = evaluate(model, test_loader)
print("Final Accuracy:", final_acc)

